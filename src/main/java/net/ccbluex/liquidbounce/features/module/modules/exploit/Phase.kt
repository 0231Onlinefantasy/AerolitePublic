/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/UnlegitMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.block.BlockUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.FloatValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.block.Block
import net.minecraft.block.BlockAir
import net.minecraft.init.Blocks
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.util.BlockPos
import net.minecraft.util.MathHelper
import java.util.*
import kotlin.math.cos
import kotlin.math.sin


@ModuleInfo(name = "Phase", category = ModuleCategory.EXPLOIT)
class Phase : Module() {
    private val modeValue = ListValue("Mode", arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "AACv4", "OldMatrix", "Mineplex", "FastFall", "Automatic", "SmartVClip"), "Vanilla")
    private val automaticOffsetValue = FloatValue("AutomaticOffset", 4.0f, -8.0f, 8.0f).displayable { modeValue.equals("Automatic") }
    private val automaticPhaseDelayValue = IntegerValue("AutomaticPhaseDelay", 1000, 500, 5000).displayable { modeValue.equals("Automatic") }
    private val automaticFreezeMotionValue = BoolValue("AutomaticFreezeMotion", true).displayable { modeValue.equals("Automatic") }
    private val tickTimer = TickTimer()
    private var mineplexClip = false
    private var noRot = false
    private val mineplexTickTimer = TickTimer()
    private val automaticPhaseTimer = MSTimer()


    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        val isInsideBlock = BlockUtils.collideBlockIntersects(mc.thePlayer.entityBoundingBox) { block: Block? -> block !is BlockAir }
        if (isInsideBlock && (modeValue.equals("Vanilla") || modeValue.equals("Skip") || modeValue.equals("Spartan") || modeValue.equals("Clip") || modeValue.equals("AAC3.5.0"))) {
            mc.thePlayer.noClip = true
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.onGround = true
        }

        tickTimer.update()

        when (modeValue.get().lowercase()) {
            "aacv4" -> {
                mc.thePlayer.sendQueue.addToSendQueue(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY + -0.00000001, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, false))
                mc.thePlayer.sendQueue.addToSendQueue(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY - 1, mc.thePlayer.posZ, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, false))
                state = false
            }
            "fastfall" -> {
                mc.thePlayer.noClip = true
                mc.thePlayer.motionY -= 10.0
                mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX, mc.thePlayer.posY - 0.5, mc.thePlayer.posZ)
                mc.thePlayer.onGround = BlockUtils.collideBlockIntersects(mc.thePlayer.entityBoundingBox) { block: Block? -> block !is BlockAir }
            }

            "oldmatrix" -> {
                mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - 3, mc.thePlayer.posZ)
                mc.gameSettings.keyBindForward.pressed = true
                MovementUtils.strafe(0.1f)
                mc.gameSettings.keyBindForward.pressed = false
            }
            "automatic" -> {
                if (automaticPhaseTimer.hasTimePassed(automaticPhaseDelayValue.get().toLong())) {
                    if (mineplexClip) {
                        mineplexClip = false
                        mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - automaticOffsetValue.get(), mc.thePlayer.posZ)
                    }
                } else if(automaticFreezeMotionValue.get()) {
                    mc.thePlayer.motionX = 0.0
                    mc.thePlayer.motionZ = 0.0
                }
            }
            "vanilla" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val x = -sin(yaw) * 0.04
                val z = cos(yaw) * 0.04
                mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z)
                tickTimer.reset()
            }
            "skip" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return
                val direction = MovementUtils.direction
                val posX = -sin(direction) * 0.3
                val posZ = cos(direction) * 0.3
                var i = 0
                while (i < 3) {
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.06, mc.thePlayer.posZ, true))
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX + posX * i, mc.thePlayer.posY, mc.thePlayer.posZ + posZ * i, true))
                    ++i
                }
                mc.thePlayer.entityBoundingBox = mc.thePlayer.entityBoundingBox.offset(posX, 0.0, posZ)
                mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX + posX, mc.thePlayer.posY, mc.thePlayer.posZ + posZ)
                tickTimer.reset()
            }
            "spartan" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return
                mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                mc.netHandler.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 0.2, mc.thePlayer.posZ, true))
                mc.netHandler.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX + 0.5, mc.thePlayer.posY, mc.thePlayer.posZ + 0.5, true))
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val x = -sin(yaw) * 0.04
                val z = cos(yaw) * 0.04
                mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z)
                tickTimer.reset()
            }
            "clip" -> {
                if (!tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val oldX = mc.thePlayer.posX
                val oldZ = mc.thePlayer.posZ
                var i = 1
                while (i <= 10) {
                    val x = -sin(yaw) * i
                    val z = cos(yaw) * i
                    if (BlockUtils.getBlock(BlockPos(oldX + x, mc.thePlayer.posY, oldZ + z)) is BlockAir
                        && BlockUtils.getBlock(BlockPos(oldX + x, mc.thePlayer.posY + 1, oldZ + z)) is BlockAir) {
                        mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z)
                        break
                    }
                    i++
                }
                tickTimer.reset()
            }
            "aac3.5.0" -> {
                if (!tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val oldX = mc.thePlayer.posX
                val oldZ = mc.thePlayer.posZ
                val x = -sin(yaw)
                val z = cos(yaw)
                mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z)
                tickTimer.reset()
            }
            "smartvclip" -> {
                val cageCollision = (mc.theWorld.getBlockState(BlockPos(mc.thePlayer).up(3)).block !== Blocks.air
                        && mc.theWorld.getBlockState(BlockPos(mc.thePlayer).down()).block !== Blocks.air)
                noRot = mc.thePlayer.ticksExisted in 0..40 && cageCollision
                if (mc.thePlayer.ticksExisted in 20..39 && cageCollision) {
                    //mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 3.999, mc.thePlayer.posZ, true));
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY - 4,
                            mc.thePlayer.posZ,
                            false
                        )
                    )
                    mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - 4, mc.thePlayer.posZ)
                }
            }
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (packet is C03PacketPlayer) {
            if (modeValue.equals("AAC3.5.0")) {
                val yaw = MovementUtils.direction.toFloat()
                packet.x = packet.x - MathHelper.sin(yaw) * 0.00000001
                packet.z = packet.z + MathHelper.cos(yaw) * 0.00000001
            } else if(modeValue.equals("Automatic")) {
                if (!mc.netHandler.doneLoadingTerrain) {
                    automaticPhaseTimer.reset()
                    mineplexClip = true
                }
            }
        }

    }

    @EventTarget
    private fun onMove(event: MoveEvent) {
        if (modeValue.equals("mineplex")) {
            if (mc.thePlayer.isCollidedHorizontally) mineplexClip = true
            if (!mineplexClip) return
            mineplexTickTimer.update()
            event.x = 0.0
            event.z = 0.0
            if (mineplexTickTimer.hasTimePassed(3)) {
                mineplexTickTimer.reset()
                mineplexClip = false
            } else if (mineplexTickTimer.hasTimePassed(1)) {
                val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
                val direction = MovementUtils.direction
                mc.thePlayer.setPosition(mc.thePlayer.posX + -sin(direction) * offset, mc.thePlayer.posY, mc.thePlayer.posZ + cos(direction) * offset)
            }
        }
        if (modeValue.get().equals("SmartVClip", true) && noRot) {
            event.zeroXZ();
        }
    }

    @EventTarget
    fun onPushOut(event: PushOutEvent) {
        event.cancelEvent()
    }

    @EventTarget
    fun onJump(event: JumpEvent) {
        if (modeValue.get().equals("SmartVClip", ignoreCase = true) && noRot) event.cancelEvent()
    }

    override val tag: String
        get() = modeValue.get()
}