package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.modules.movement.Fly
import net.ccbluex.liquidbounce.features.module.modules.movement.Speed
import net.ccbluex.liquidbounce.features.module.modules.movement.NewTargetStrafe
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.NotifyType
import net.ccbluex.liquidbounce.ui.font.Fonts
import net.ccbluex.liquidbounce.utils.*
import net.ccbluex.liquidbounce.utils.MovementUtils.isMoving
import net.ccbluex.liquidbounce.utils.extensions.drawCenteredString
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.client.gui.ScaledResolution
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.S02PacketChat
import net.minecraft.network.play.server.S07PacketRespawn
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.network.play.server.S2BPacketChangeGameState
import net.minecraft.util.BlockPos
import java.awt.Color
import java.util.*
import kotlin.math.pow
import kotlin.math.roundToInt
import kotlin.math.sqrt

/**
 * credits: LatestVerus -> Astromero Client
 */
@ModuleInfo(name = "Disabler", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {
    private val modeValue = ListValue("Mode", arrayOf("MineplexCombat", "BlocksmcNew", "VulcanCombat","Basic", "Flag", "OldVerusCombat", "OldVerusCombat2", "OldVerusMove", "OldGhostly", "LatestVerus", "Flying", "Riding", "Spectate", "SpectateSpoof", "SpectateSpoof2", "LessFlag", "C13+InfiniteC0C", "NoGroundTouch", "OldMatrix", "Kauri", "FakeLag", "Hypixel", "Hypixel2", "Hypixel3", "MoonAC-Punishments", "Matrix"), "MineplexCombat")
    private val alertValue = BoolValue("alert", false)
    private val memeAACValue = BoolValue("OldMatrixWithAAC5", false).displayable { modeValue.equals("OldMatrix") }
    private val fakeLagPosValue = BoolValue("FakeLagPosition", true).displayable { modeValue.equals("FakeLag") }
    private val fakeLagBlockValue = BoolValue("FakeLagBlock", true).displayable { modeValue.equals("FakeLag") }
    private val fakeLagAttackValue = BoolValue("FakeLagAttack", true).displayable { modeValue.equals("FakeLag") }
    private val fakeLagSpoofValue = BoolValue("FakeLagC03Spoof", false).displayable { modeValue.equals("FakeLag") }
    private val lagDelayValue = IntegerValue("LagDelay", 0, 0, 2000).displayable { modeValue.equals("FakeLag") }
    private val lagDurationValue = IntegerValue("LagDuration", 200, 100, 1000).displayable { modeValue.equals("FakeLag") }
    private val matrixNoCheck = BoolValue("Matrix-NoModuleCheck", false).displayable { modeValue.equals("matrix") }
    private val matrixMoveFix = BoolValue("Matrix-MoveFix", true).displayable { modeValue.equals("matrix") }
    private val matrixMoveOnly = BoolValue("Matrix-MoveOnly", false).displayable { modeValue.equals("matrix") }
    private val matrixNoMovePacket = BoolValue("Matrix-NoMovePacket", true).displayable { modeValue.equals("matrix") }
    private val matrixHotbarChange = BoolValue("Matrix-HotbarChange", true).displayable { modeValue.equals("matrix") }
    private val flagMode = ListValue("Flag-Mode", arrayOf("Edit", "Packet"), "Edit").displayable { modeValue.equals("flag") }
    private val flagTick = IntegerValue("Flag-TickDelay", 25, 1, 200).displayable { modeValue.equals("flag") }
    private val flagSilent = BoolValue("Flag-SilentMode", true).displayable { modeValue.equals("flag") }
    private val verusSlientFlagApplyValue = BoolValue("VerusSlientFlagApply", false).displayable { modeValue.equals("OldVerusMove") || modeValue.equals("LatestVerus") }
    private val verusBufferSizeValue = IntegerValue("VerusBufferSize", 300, 0, 1000).displayable { modeValue.equals("LatestVerus") }
    private val verusRepeatTimesValue = IntegerValue("Verus-RepeatTimes", 1, 1, 5).displayable { modeValue.equals("OldVerusMove") || modeValue.equals("LatestVerus") }
    private val verusRepeatTimesFightingValue = IntegerValue("Verus-RepeatTimesFighting", 1, 1, 5).displayable { modeValue.equals("OldVerusMove") || modeValue.equals("LatestVerus") }
    private val verusFlagDelayValue = IntegerValue("Verus-FlagDelay", 40, 35, 60).displayable { modeValue.equals("LatestVerus") }
    private val watchDogAntiBan = BoolValue("WatchDog Disabler", false).displayable { modeValue.equals("Hypixel2") }

    // watchdog
    private val renderServer = BoolValue("Render-ServerSide", false).displayable { modeValue.get().equals("Hypixel3", true) }
    private val autoAlert = BoolValue("BanAlert", false).displayable { modeValue.get().equals("Hypixel3", true) }
    private val rotModify = BoolValue("RotationModifier", false).displayable { modeValue.get().equals("Hypixel3", true) }
    private val tifality90 = BoolValue("Tifality", false).displayable { modeValue.get().equals("Hypixel3", true) && rotModify.get() }
    private val noMoveKeepRot = BoolValue("NoMoveKeepRot", true).displayable { modeValue.get().equals("Hypixel3", true) && rotModify.get() }
    private val noC03s = BoolValue("NoC03s", true).displayable { modeValue.get().equals("Hypixel3", true) }
    private val testFeature = BoolValue("PingSpoof", false).displayable { modeValue.get().equals("Hypixel3", true) }
    private val testDelay = IntegerValue("Delay", 400, 0, 1000).displayable { modeValue.get().equals("Hypixel3", true) && testFeature.get() }
    private val checkValid = BoolValue("InvValidate", false).displayable { modeValue.get().equals("Hypixel3", true) && testFeature.get() }

    private var verus2Stat = false
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()
    private var currentTrans = 0
    private var memeTick = 0
    private var isSent = false
    private val fakeLagDelay = MSTimer()
    private val fakeLagDuration = MSTimer()
    private val HypixelDebug = MSTimer()

    private var counter = 0
    private var lastYaw = 0F
    private var x = 0.0
    private var y = 0.0
    private var z = 0.0

    private var alrSendY = false
    private var alrSprint = false
    private var shouldActive = false
    private val packetQueue = LinkedList<C0FPacketConfirmTransaction>()
    private val anotherQueue = LinkedList<C00PacketKeepAlive>()
    private val wdTimer = MSTimer()
    var shouldModifyRotation = false

    private var modified = false

    private val repeatTimes: Int
        get() = if(LiquidBounce.combatManager.inCombat) { verusRepeatTimesFightingValue.get() } else { verusRepeatTimesValue.get() }

    fun isInventory(action: Short): Boolean = action > 0 && action < 100

    val canRenderInto3D: Boolean
        get() = (state && modeValue.get().equals("Hypixel3", true) && renderServer.get() && shouldModifyRotation)

    override fun onEnable() {
        alrSendY = false
        alrSprint = false
        shouldActive = false
        reset()
    }

    override fun onDisable() {
        modified = false
        if (modeValue.get().equals("Hypixel3", true)) {
            anotherQueue.forEach { PacketUtils.sendPacketNoEvent(it) }
            packetQueue.forEach { PacketUtils.sendPacketNoEvent(it) }
        }
        when (modeValue.get().lowercase()) {
            "oldmatrix" -> {
                for (packet in packetBuffer) {
                    PacketUtils.sendPacketNoEvent(packet)
                }
                packetBuffer.clear()
            }
            "fakelag" -> {
                for (packet in packetBuffer) {
                    PacketUtils.sendPacketNoEvent(packet)
                }
                packetBuffer.clear()
            }
            "hypixel" -> {
                counter = 0
            }
            "blocksmcnew"-> {
                counter = 0
            }
            "hypixel2" -> {
                counter = 0
            }
        }
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        alrSendY = false
        alrSprint = false
        reset()
    }

    private fun reset() {
        memeTick = 0
        currentTrans = 0
        verus2Stat = false
        packetBuffer.clear()
        fakeLagDelay.reset()
        fakeLagDuration.reset()
        counter = 0
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        modified = false
        when (modeValue.get().lowercase()) {
            "oldveruscombat2" -> {
                mc.timer.timerSpeed = 0.6F
                if (mc.thePlayer.ticksExisted % 50 == 0 && (packetBuffer.size - 1) > currentTrans) {
                    verus2Stat = true
                    PacketUtils.sendPacketNoEvent(packetBuffer[++currentTrans])
                    alertMessage("Send Trans")
                }
                if (mc.thePlayer.ticksExisted % 500 == 0) {
                    packetBuffer.clear()
                    alertMessage("Clear Trans")
                    currentTrans = 0
                }
            }

            "oldverusmove" -> {
                // Partially drain the queue every 180 ticks (9 seconds), to prevent flagging Ping Spoof.
                if (mc.thePlayer.ticksExisted % 180 == 0) {
                    // grab packets untill the queue size is 22 or less.
                    while (packetBuffer.size > 22) {
                        // grab 1 packet, send and then remove it from the queue
                        PacketUtils.sendPacketNoEvent(packetBuffer[0])
                        packetBuffer.removeAt(0)
                    }
                }
            }
            //

            "latestverus" -> {
                if(fakeLagDelay.hasTimePassed(490L)) {
                    fakeLagDelay.reset()
                    if(packetBuffer.isNotEmpty()) {
                        val packet = packetBuffer.poll()
                        repeat(repeatTimes) {
                            PacketUtils.sendPacketNoEvent(packet)
                        }
                        alertMessage("RELEASE")
                    } else {
                        alertMessage("RELEASE BUT EMPTY")
                    }
                }
            }


            "vulcancombat" -> {
                if(fakeLagDelay.hasTimePassed(5000L) && packetBuffer.size > 4) {
                    fakeLagDelay.reset()
                    while (packetBuffer.size > 4) {
                        PacketUtils.sendPacketNoEvent(packetBuffer.poll())
                    }
                }
            }


            "oldmatrix" -> {
                memeTick++
                val cTick = if (memeAACValue.get()) {
                    (mc.timer.timerSpeed.toDouble().pow(2.0) * 10).roundToInt()
                } else {
                    (mc.timer.timerSpeed.toDouble().pow(2.0) * 7.6).roundToInt()
                }
                if (memeTick >= cTick) {
                    memeTick = 0
                    for (packet in packetBuffer) {
                        PacketUtils.sendPacketNoEvent(packet)
                    }

                    alertMessage("Release buf(size=${packetBuffer.size}, cTick=$cTick)")
                    packetBuffer.clear()
                }
            }

            "fakelag" -> {
                if (!fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) fakeLagDuration.reset()
                // Send
                if (fakeLagDuration.hasTimePassed(lagDurationValue.get().toLong())) {
                    fakeLagDelay.reset()
                    fakeLagDuration.reset()
                    for (packet in packetBuffer) {
                        PacketUtils.sendPacketNoEvent(packet)
                    }
                    alertMessage("Release buf(size=${packetBuffer.size})")
                    isSent = true
                    packetBuffer.clear()
                }
            }

            "hypixel2" -> {
                if(mc.thePlayer.onGround && PlayerUtils.isBlockUnder() && mc.thePlayer.fallDistance > 10){
                    mc.netHandler.addToSendQueue(C00PacketKeepAlive(RandomUtils.nextInt(0,1000)))
                    alertMessage("Packet C00")
                }
                if(mc.thePlayer.ticksExisted % 180 == 90){
                    if(mc.thePlayer.onGround && mc.thePlayer.fallDistance > 10){
                        mc.netHandler.addToSendQueue(C00PacketKeepAlive(RandomUtils.nextInt(0,1000)))
                        alertMessage("Packet C0B")
                        mc.timer.timerSpeed=0.8f
                    }else{
                        if(mc.thePlayer.fallDistance<10) {
                            if (mc.thePlayer.posY == mc.thePlayer.fallDistance.toDouble()) {
                                mc.netHandler.addToSendQueue(C03PacketPlayer(false))
                                if(mc.thePlayer.onGround) mc.timer.timerSpeed = 0.4f
                                if(mc.thePlayer.fallDistance==0f) mc.netHandler.addToSendQueue(C03PacketPlayer(true))
                                alertMessage("Packet C03")
                            }
                        }
                    }
                }
                if(mc.thePlayer.posY != 0.0){
                    val times=10000 / if(mc.thePlayer.fallDistance.toLong() != 0L) mc.thePlayer.fallDistance.toLong() else 1
                    if(HypixelDebug.hasTimePassed(if(times<100) 100 else times) && !mc.thePlayer.onGround && mc.thePlayer.fallDistance != 0f){
                        HypixelDebug.reset()
                        alertMessage("Watchdog disabled")
                    }else{
                        if(mc.thePlayer.fallDistance == 0f) HypixelDebug.reset()
                    }
                    if (mc.thePlayer.getItemInUseDuration() >= 1 && PlayerUtils.isUsingFood()) {
                        mc.netHandler.addToSendQueue(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
                    }else{
                        mc.netHandler.addToSendQueue(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
                    }
                }
            }
        }
    }

    @EventTarget
    fun onRender2D() {
        if (!shouldActive)
        {
            val sc = ScaledResolution(mc)
            if ((modeValue.get().equals("Hypixel3", true) && testFeature.get()) && !ServerUtils.isHypixelLobby()) {
                RenderUtils.drawRect(sc.scaledWidth / 2F - 50F, 60F, sc.scaledWidth / 2F + 50F, 72F, Color(0, 0, 0, 140).rgb)
                Fonts.font40.drawCenteredString("Please wait...", sc.scaledWidth / 2F, 62F, Color(220, 220, 50).rgb)
            }
        }
    }


    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        when (modeValue.get().lowercase()) {
            "flag" -> {
                if (packet is C03PacketPlayer && flagMode.get().equals("edit", true) && mc.thePlayer.ticksExisted > 0 && mc.thePlayer.ticksExisted % flagTick.get() == 0)
                {
                    packet.isMoving = false
                    packet.onGround = false
                    packet.y = -0.08

                    alertMessage("flagged")
                }
                if (packet is S08PacketPlayerPosLook && flagSilent.get()) {
                    if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

                    val x = packet.getX() - mc.thePlayer.posX
                    val y = packet.getY() - mc.thePlayer.posY
                    val z = packet.getZ() - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), true))

                        alertMessage("silent s08 accept")
                    }
                }
            }

            "basic" -> if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) event.cancelEvent()

            "oldghostly" -> {
                if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput())
                if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) event.cancelEvent()
            }

            "matrix" -> {
                if (matrixNoCheck.get() || LiquidBounce.moduleManager.getModule(Speed::class.java)!!.state || LiquidBounce.moduleManager.getModule(
                        Fly::class.java)!!.state) {
                    if (packet is C03PacketPlayer) {
                        if (matrixNoMovePacket.get() && !packet.isMoving()) {
                            event.cancelEvent()
                            alertMessage("no move, cancelled")
                            return
                        }
                        if (matrixMoveFix.get()) {
                            // almost completely disable strafe check, nofall
                            packet.onGround = true
                            if (!packet.rotating) { // fix fly sometimes doesn't land properly since 1.8.x servers all refer to C04, C05, C06 as C03s.
                                packet.rotating = true
                                packet.yaw = mc.thePlayer.rotationYaw
                                packet.pitch = mc.thePlayer.rotationPitch
                            }
                        }
                    }
                }
            }

            "moonac-punishments" -> {
                if (packet is S2BPacketChangeGameState && ((packet.getGameState() == 5 && !mc.isDemo()) || packet.getGameState() == 10)) {
                    // 5 = demo screen, 10 = guardian sound + animations
                    event.cancelEvent()
                    alertMessage("found attempt to trigger ${if (packet.getGameState() == 5) "demo screen" else "guardian effects"}.")
                }

                if (packet is S02PacketChat && packet.getChatComponent() != null &&
                    packet.getChatComponent().getUnformattedText().startsWith("GET TROLL", true))
                    event.cancelEvent()
            }

            "mineplexcombat" -> {
                if (packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(C00PacketKeepAlive(packet.key - RandomUtils.nextInt(1000, 2147483647)))
                    alertMessage("Packet C00")
                }
            }

            "lessflag" -> {
                if (packet is S08PacketPlayerPosLook) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
                        alertMessage("Flag Reduced")
                    } else {
                        alertMessage("Too Far Away")
                    }
                }
            }

//            "verussemi" -> {
//                if (packet is C03PacketPlayer) {
//                    packet.onGround = if(packet.isMoving) {
//                        (verusLastY == packet.y && mc.thePlayer.motionY <= 0).also { verusLastY = packet.y }
//                    } else {
//                        true
//                    }
//                    chat("OG ${packet.onGround} ${verusLastY}")
//                }
//            }

            "oldveruscombat" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if (currentTrans > 0) event.cancelEvent()
                    currentTrans++
                    alertMessage("Packet C0F (Trans=$currentTrans)")
                } else if (packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                    alertMessage("Packet C0B")
                }
            }

            "oldveruscombat2" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if (!verus2Stat) {
                        packetBuffer.add(packet)
                        alertMessage("Add Packet")
                        event.cancelEvent()
                    } else {
                        verus2Stat = false
                    }
                } else if (packet is C00PacketKeepAlive) {
                    PacketUtils.sendPacketNoEvent(C00PacketKeepAlive(RandomUtils.nextInt(1, 2147483647)))
                    alertMessage("Keep Alive")
                    event.cancelEvent()
                } else if (packet is C03PacketPlayer) {
                    PacketUtils.sendPacketNoEvent(C0CPacketInput())
                    if (mc.thePlayer.ticksExisted % 15 == 0) {
                        packet.y += RandomUtils.nextInt(100, 1000)
                        alertMessage("Packet C03")
                    }
                }
            }

            "oldverusmove" -> {
                if (mc.thePlayer != null && mc.thePlayer.ticksExisted == 0) packetBuffer.clear()
                if (packet is C03PacketPlayer) {
                    // Set position to a valid block height (so Spoof NoFall works)
                    val yPos = (mc.thePlayer.posY / 0.015625).roundToInt() * 0.015625
                    mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)
                    if (mc.thePlayer.ticksExisted % 45 == 0) {
                        // Clip into ground and silently accept the teleport from the server. (This fucks with teleport compensation LOL)
                        PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                        PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 11.725, mc.thePlayer.posZ, false))
                        PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                    }
                } else if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    // Cancel the teleport, and silently accept it.
                    if (diff <= 8) {
                        event.cancelEvent()
                        // LATEST verus ALWAYS expects a c06 within 30 seconds of a teleport if packets have been sent from the client after the teleport.
                        PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
                    }
                } else if (packet is C0FPacketConfirmTransaction) {
                    repeat(repeatTimes) {
                        // Make sure to dupe packets 4 times, since it will match up with the missing packets while keeping the anticheat disabled, in order to bypass ping spoof checks
                        // why the fuck do they not checked duped transactions? LMFAO
                        packetBuffer.add(packet)
                        event.cancelEvent()
                    }
                }
            }

            "latestverus" -> {
                if(packet is C0FPacketConfirmTransaction) {
                    packetBuffer.add(packet)
                    event.cancelEvent()
                    if(packetBuffer.size > verusBufferSizeValue.get()) {
                        if(!verus2Stat) {
                            verus2Stat = true
                            LiquidBounce.hud.addNotification(Notification(name, "AntiCheat is disabled.", NotifyType.SUCCESS, 3000))
                        }
                        val packet = packetBuffer.poll()
                        repeat(repeatTimes) {
                            PacketUtils.sendPacketNoEvent(packet)
                        }
                    }
                    alertMessage("C0F IN ${packetBuffer.size}")
                } else if(packet is C03PacketPlayer) {
                    if((mc.thePlayer.ticksExisted % verusFlagDelayValue.get() == 0) && (mc.thePlayer.ticksExisted > verusFlagDelayValue.get() + 1) && !modified) {
                        alertMessage("C03 MODIFY")
                        modified = true
                        packet.y -= 11.4514 // 逸一时，误一世
                        packet.onGround = false
                    }
                } else if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        // why didnt they check flag apply delay? LMAO
                        alertMessage("FLAG APPLY")
                        PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
                    }
                }

                if (mc.thePlayer != null && mc.thePlayer.ticksExisted <= 7) {
                    fakeLagDelay.reset()
                    packetBuffer.clear()
                }
            }

            "kauri" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    event.cancelEvent()
                }
            }

            "riding" -> {
                if (packet is C03PacketPlayer) {
                    mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
                }
            }

            "basic" -> {
                if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                }
            }

            "nogroundtouch" -> {
                if (packet is C03PacketPlayer) {
                    packet.y += 0.125
                }
            }

            "spectate" -> {
                if (packet is C03PacketPlayer) {
                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                }
            }

            "spectatespoof" -> {
                if (packet is C03PacketPlayer) {
                    packet.onGround = false

                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                }
                if (packet is C13PacketPlayerAbilities) {
                    packet.isFlying = true
                    packet.isInvulnerable = true
                    packet.isAllowFlying = true
                    packet.isCreativeMode = false
                }
            }

            "spectatespoof2" -> {
                if (packet is C03PacketPlayer) {
                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                }
                if (packet is C13PacketPlayerAbilities) {
                    packet.isFlying = true
                    packet.isInvulnerable = true
                    packet.isAllowFlying = true
                    packet.isCreativeMode = false
                }
            }

            "flying" -> {
                if (packet is C03PacketPlayer) {
                    val capabilities = PlayerCapabilities() // flags=2
                    capabilities.disableDamage = false
                    capabilities.isFlying = true
                    capabilities.allowFlying = false
                    capabilities.isCreativeMode = false
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
                    alertMessage("Packet C13")
                }
            }

            "oldmatrix" -> {
                if (packet is C03PacketPlayer && !(packet is C04PacketPlayerPosition||packet is C05PacketPlayerLook ||packet is C06PacketPlayerPosLook)) {
                    event.cancelEvent()
                }
                if (packet is C02PacketUseEntity || packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook ||
                    packet is C06PacketPlayerPosLook || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
                    packet is C0APacketAnimation || packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                }
            }

            "fakelag" -> {
                if (fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) {
                    if (isSent && fakeLagSpoofValue.get()) {
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                        if (lagDurationValue.get() >= 300) PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                        isSent = false
                    }
                    if (packet is C00PacketKeepAlive || packet is C0FPacketConfirmTransaction) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if (fakeLagAttackValue.get() && (packet is C02PacketUseEntity || packet is C0APacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                        if (packet is C0APacketAnimation) return
                    }
                    if (fakeLagBlockValue.get() && (packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement || packet is C0APacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if (fakeLagPosValue.get() && (packet is C03PacketPlayer || packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook || packet is C06PacketPlayerPosLook || packet is C0BPacketEntityAction)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                }
            }

            "c13+infinitec0c" -> {
                PacketUtils.sendPacketNoEvent(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                PacketUtils.sendPacketNoEvent(C0CPacketInput(Float.MAX_VALUE, Float.MAX_VALUE, false, false))
            }
            "hypixel" -> {
                if (event.packet is C06PacketPlayerPosLook) {
                    if (counter > 0) {
                        if (event.packet.x == x && event.packet.y == y && event.packet.z == z) {
                            mc.netHandler.networkManager.sendPacket(C04PacketPlayerPosition(event.packet.x, event.packet.y, event.packet.z, event.packet.onGround))
                            alertMessage("[Disabler] Packet C04")
                            event.cancelEvent()
                        }
                    }
                    counter += 1

                    if (event.packet is C05PacketPlayerLook && mc.thePlayer.isRiding) {
                        mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.START_SPRINTING))
                        alertMessage("[Disabler] Packet C0B")
                    } else if (event.packet is C0CPacketInput && mc.thePlayer.isRiding) {
                        mc.netHandler.networkManager.sendPacket(event.packet)
                        mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SNEAKING))
                        alertMessage("[Disabler] Packet C0B")
                        event.cancelEvent()
                    }
                }

                if (event.packet is S08PacketPlayerPosLook) {
                    val s08 = event.packet
                    x = s08.x
                    y = s08.y
                    z = s08.z
                    alertMessage("[Disabler] Receive S08")
                }

                if (event.packet is S07PacketRespawn) {
                    counter = 0
                }
            }
            "blocksmcnew" -> {
            if (event.packet is C06PacketPlayerPosLook) {
                if (counter > 1) {
                    if (event.packet.x == x && event.packet.y == y && event.packet.z == z) {
                        mc.netHandler.networkManager.sendPacket(C04PacketPlayerPosition(event.packet.x, event.packet.y, event.packet.z, event.packet.onGround))
                        alertMessage("C04 Sent")
                        event.cancelEvent()
                    }
                }
                counter += 1
            }

            if (event.packet is S08PacketPlayerPosLook) {
                val s08 = event.packet
                x = s08.x
                y = s08.y
                z = s08.z
                alertMessage("S08 Receive")
            }

            if (event.packet is S07PacketRespawn) {
                counter = 0
            }
        }
            "hypixel2" -> {
                if(!watchDogAntiBan.get()){
                    if (event.packet is C06PacketPlayerPosLook && mc.thePlayer.onGround && mc.thePlayer.fallDistance>10) {
                        if (counter > 0) {
                            if (event.packet.x == x && event.packet.y == y && event.packet.z == z) {
                                mc.netHandler.networkManager.sendPacket(C04PacketPlayerPosition(event.packet.x, event.packet.y, event.packet.z, event.packet.onGround))
                                alertMessage("Packet C04")
                                event.cancelEvent()
                            }
                        }
                        counter += 1

                        if (event.packet is C05PacketPlayerLook && mc.thePlayer.isRiding) {
                            mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.START_SPRINTING))
                            alertMessage("Packet C0B")
                        } else if (event.packet is C0CPacketInput && mc.thePlayer.isRiding) {
                            mc.netHandler.networkManager.sendPacket(event.packet)
                            mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SNEAKING))
                            alertMessage("Packet C0B")
                            event.cancelEvent()
                        }
                    }

                    if (event.packet is S08PacketPlayerPosLook) {
                        val s08 = event.packet
                        x = s08.x
                        y = s08.y
                        z = s08.z
                        alertMessage("Receive S08")
                    }

                    if (event.packet is S07PacketRespawn) {
                        counter = 0
                    }
                }
            }
            "Hypixel3" -> {
                if (mc.isSingleplayer()) return

                if (autoAlert.get() && packet is S02PacketChat && packet.getChatComponent().getUnformattedText().contains("Cages opened!", true))
                    LiquidBounce.hud.addNotification(Notification(this.name, "Speed is bannable until this notification disappears", NotifyType.WARNING, 20000))

                if (testFeature.get() && !ServerUtils.isHypixelLobby()) {
                    if (packet is C0FPacketConfirmTransaction && (!checkValid.get() || !isInventory(packet.uid))) {
                        event.cancelEvent()
                        packetQueue.add(packet)

                        alertMessage("C0f, ${packet.uid} ID, ${packet.windowId} wID")

                        if (!shouldActive) {
                            shouldActive = true
                            alertMessage("activated")
                        }
                    }
                    if (packet is C00PacketKeepAlive) {
                        event.cancelEvent()
                        anotherQueue.add(packet)

                        wdTimer.reset()
                        alertMessage("C00, ${packet.key}")
                    }
                    if (packet is C03PacketPlayer || packet is C0BPacketEntityAction || packet is C08PacketPlayerBlockPlacement || packet is C0APacketAnimation) {
                        if (!shouldActive) {
                            event.cancelEvent()
                        }
                    }
                    if (packet is S08PacketPlayerPosLook && !shouldActive) {
                        if (alrSendY) {
                            //mc.netHandler.addToSendQueue(C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), false))
                            event.cancelEvent()
                            alertMessage("no S08")
                        } else {
                            alrSendY = true
                            alertMessage("first S08, ignore")
                        }
                    }
                }

                if (noC03s.get() && packet is C03PacketPlayer)
                    if (packet !is C04PacketPlayerPosition && packet !is C05PacketPlayerLook && packet !is C06PacketPlayerPosLook) {
                        event.cancelEvent()
                    }
            }
        }
    }

    @EventTarget(priority = 2)
    fun onMotion(event: MotionEvent) {
        shouldModifyRotation = false
        val speed = LiquidBounce.moduleManager.getModule(Speed::class.java)!!
        val fly = LiquidBounce.moduleManager.getModule(Fly::class.java)!!
        val targetStrafe = LiquidBounce.moduleManager.getModule(NewTargetStrafe::class.java)!!
        if (modeValue.get().equals("Hypixel3", true)) {
            if (event.eventState == EventState.PRE) {
                if ((speed.state || fly.state) && rotModify.get()) {
                    shouldModifyRotation = true
                    if (isMoving()) {
                        val cYaw = if (targetStrafe.canStrafe) MovementUtils.getPredictionYaw(event.x, event.z) - 90F
                        else MovementUtils.getRawDirection()

                        lastYaw = cYaw
                        RotationUtils.setTargetRotation(Rotation(cYaw, if (tifality90.get()) 90F else event.pitch))
                        event.yaw = cYaw
                        if (tifality90.get()) event.pitch = 90F
                    } else if (noMoveKeepRot.get()) {
                        RotationUtils.setTargetRotation(Rotation(lastYaw, if (tifality90.get()) 90F else event.pitch))
                        event.yaw = lastYaw
                        if (tifality90.get()) event.pitch = 90F
                    }
                }
                if (mc.isSingleplayer()) return
                if (testFeature.get() && !ServerUtils.isHypixelLobby()) {
                    if (shouldActive && wdTimer.hasTimePassed(testDelay.get().toLong())) {
                        while (!anotherQueue.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(anotherQueue.poll())
                            alertMessage("C00, ${anotherQueue.size}")
                        }
                        while (!packetQueue.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(packetQueue.poll())
                            alertMessage("C0f, ${packetQueue.size}")
                        }
                    }
                }
            }
        }

        if (event.eventState == EventState.POST && (!matrixMoveOnly.get() || isMoving())) // check post event
            if (modeValue.get().equals("matrix", true)) {
                if (matrixNoCheck.get() || LiquidBounce.moduleManager.getModule(Fly::class.java)!!.state || LiquidBounce.moduleManager.getModule(Speed::class.java)!!.state) {
                    var changed = false
                    if (matrixHotbarChange.get()) for (i in 0..8) {
                        // find a empty inventory slot
                        if(mc.thePlayer.inventory.mainInventory[i] == null && i != mc.thePlayer.inventory.currentItem) {
                            PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(i))
                            changed = true
                            alertMessage("found empty slot $i, switching")
                            break
                        }
                    }

                    PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, RotationUtils.serverRotation.yaw, RotationUtils.serverRotation.pitch, mc.thePlayer.onGround))
                    mc.netHandler.addToSendQueue(C08PacketPlayerBlockPlacement(BlockPos(-1, -1, -1), -1, null, 0f, 0f, 0f))
                    alertMessage("sent placement")

                    if (changed) {
                        PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
                        alertMessage("switched back")
                    }
                }
            }
    }

    private fun alertMessage(str: String) {
        if (alertValue.get()) {
            alert("$str")
        }
    }

    override val tag: String
        get() = modeValue.get()
}